# 동적 계획법
  * 입력 크기가 작은 부분 문제들을 해결한 후 해당 부분의 값을 활용하여 보다 큰 크기의 부분 문제를 해결. 최종적으로 전체 문제를 해결하는 알고리즘
  * **상향식 접근법**(최하위 해답을 구한 후 해당 결과를 이용해서 상위 문제를 풀어가는 방식)
  * 프로그램 실행시 이전의 계산한 값을 저장하여 다시 계산하지 않도록 전체 실행 속도를 빠르게 하는 기술
  * 문제를 잘게 쪼갤 때 부분 문제는 중복되기 때문에 재활용(예: 피보나치 수열)

# 동적 계획법을 이용한 피보나치 수열 구하기 

```C++

#include <iostream>
#include <vector>


int fibonacce(int num) {
    std::vector<int> cache(num + 1, 0); 
    // 미리 vector를 하는 이유는 프로그램 실행시 다시 계산하지 않도록 할려고
    cache[0] = 0;
    cache[1] = 1;
    // 보통 피보나치 수열을 계산할 때 F[n] = F[ n - 1] + F[n - 2]를 사용하기 때문에
    // 미리 인덱스 0번과 1번의 값을 초기화하여 인덱스 2번 부터 쉽게 계산하기 위해
    // 인덱스 0번과 1번을 초기화 한다.

    for (size_t index = 2; index < cache.size(); index++) {
        cache[index] = cache[index - 1] + cache[index - 2];
    }
    return cache[num];
    // 일반적인 동적 계획법 문제는 가장 적은 경우의 수 부터 계산한 후 피보나치 수열 처럼
    // 패턴을 찾는 거

}

int main() {
   
    std::cout << fibonacce(10) << std::endl;

}


```
